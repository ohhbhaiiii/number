1. CRC 
client:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>


#define PORT 8000
#define N strlen(crc_key)


void XOR();
int i, j;
char data[20];
char crc_key[20];
char checksum[20];


int main()
{
    struct sockaddr_in serveraddress;


    int clientsocket;
    clientsocket = socket(AF_INET, SOCK_STREAM, 0);
    if(clientsocket<0)
    {
        printf("socket creation failed\n");
        return -1;
    }


    serveraddress.sin_family = AF_INET;
    serveraddress.sin_port = htons(PORT);
    serveraddress.sin_addr.s_addr = INADDR_ANY;


    int connection_status;
    connection_status = connect(clientsocket, (struct sockaddr *)&serveraddress, sizeof(serveraddress));
    if(connection_status < 0)
    {
        printf("connection failed\n");
        return -1;
    }
    else
        printf("connection established\n");




    printf("Enter the data to be transmitted: ");
    scanf("%s", data);


    printf("Enter the CRC key: ");
    scanf("%s", crc_key);


    int data_length = strlen(data);


    for(i = data_length; i<data_length+N-1; i++)
        data[i] = '0';
    printf("new data = %s\n", data);


    for(i = 0; i<N; i++)
        checksum[i] = data[i];
    
    do
    {
        if(checksum[0] == '1')
            XOR();
        for(j = 0; j<N-1; j++)
            checksum[j] = checksum[j+1];
        checksum[j] = data[i++];
    } while (i <= data_length+N-1);


    printf("The check value is: %s\n", checksum);
    
    for(i=data_length; i<data_length+N-1; i++)
        data[i] = checksum[i-data_length];
    
    printf("The final data to be sent is: %s\n", data);


    send(clientsocket, data, sizeof(data), 0);
    send(clientsocket, crc_key, sizeof(crc_key), 0);
    send(clientsocket, checksum, sizeof(checksum), 0);


    /*char error_msg[30];
    recv(clientsocket, error_msg, sizeof(error_msg), 0);
    printf("Error status: %s\n", error_msg);*/




    close(clientsocket);


    return 0;
}


void XOR()
{
    for(j=1; j<N; j++)
        checksum[j] = ((checksum[j] == crc_key[j]) ? '0' : '1');
}
server:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>


#define PORT 8000
#define N strlen(crc_key)


int i, j;
int count = 0;
char data[20];
char crc_key[20];
char checksum[20];


void XOR()
{
    for(j=1; j<N; j++)
        checksum[j] = ((checksum[j] == crc_key[j]) ? '0' : '1');
}


int main()
{
    int serversocket, clientsocket, bindstatus;
    char servermessage[256];
    struct sockaddr_in serveraddress, clientaddress;
    int client_address_len = sizeof(clientaddress);


    serversocket = socket(AF_INET, SOCK_STREAM, 0);
    if (serversocket < 0)
    {
        printf("socket failed\n");
        return -1;
    }


    serveraddress.sin_family = AF_INET;
    serveraddress.sin_port = htons(PORT);
    serveraddress.sin_addr.s_addr = INADDR_ANY;


    bindstatus = bind(serversocket, (const struct sockaddr *)&serveraddress, sizeof(serveraddress));
    if (bindstatus < 0)
    {
        printf("binding failed\n");
        return -1;
    }
    else
    {
        printf("binding is successful\n");
    }


    listen(serversocket, 3);
    printf("Waiting for client connection...\n");


    clientsocket = accept(serversocket, (struct sockaddr *)&clientaddress, (socklen_t *)&client_address_len);
    if (clientsocket < 0)
    {
        printf("connection is rejected by server\n");
        return -1;
    }
    else
    {
        printf("connection is accepted\n");
    }




    recv(clientsocket, data, sizeof(data), 0);
    recv(clientsocket, crc_key, sizeof(crc_key), 0);
    recv(clientsocket, checksum, sizeof(checksum), 0);




    printf("Received data is: %s\n", data);


    int data_length = strlen(data);


    for(i=0; i<N; i++)
        checksum[i] = data[i];


    do{
        if(checksum[0] == '1')
            XOR();
        for(j=0; j<N-1; j++)
            checksum[j] = checksum[j+1];
        checksum[j] = data[i++];
    }while(i <= data_length+N-1);


    for(i = 0; i<N; i++)
    {
        if(checksum[i] == '1')
            count++;
        else
            count = 0;
    }


    if(count < 0)
        printf("error detected\n");
    else
        printf("no error detected\n");




    close(serversocket);
    return 0;
}
2.framing
a) bit stuffing
client:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>


#define PORT 8000
#define N 


void bitStuff(char* input, char* output) {
    int inputLength = strlen(input);
    int outputIndex = 0;
    int consecutiveOnes = 0;


    for (int i = 0; i < inputLength; i++) {
        output[outputIndex++] = input[i];


        if (input[i] == '1') {
            consecutiveOnes++;


            if (consecutiveOnes == 5) {
                output[outputIndex++] = '0';  // Add a '0' after 5 consecutive '1s'
                consecutiveOnes = 0;           // Reset consecutiveOnes counter
            }
        } else {
            consecutiveOnes = 0;  // Reset consecutiveOnes counter if a '0' is encountered
        }
    }


    output[outputIndex] = '\0';  // Null-terminate the output string
}


int main()
{
    struct sockaddr_in serveraddress;


    int clientsocket;
    clientsocket = socket(AF_INET, SOCK_STREAM, 0);
    if(clientsocket<0)
    {
        printf("socket creation failed\n");
        return -1;
    }


    serveraddress.sin_family = AF_INET;
    serveraddress.sin_port = htons(PORT);
    serveraddress.sin_addr.s_addr = INADDR_ANY;


    int connection_status;
    connection_status = connect(clientsocket, (struct sockaddr *)&serveraddress, sizeof(serveraddress));
    if(connection_status < 0)
    {
        printf("connection failed\n");
        return -1;
    }
    else
        printf("connection established\n");


    char input[256];
    char output[256];
    printf("Enter Data: ");
    scanf("%s",input);


    bitStuff(input, output);


    printf("After bit stuffing %s\n", output);
   
    send(clientsocket,output,strlen(output),0);


    close(clientsocket);


    return 0;
}

server:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>


#define PORT 8000
#define N 


void ogdata(char *output,char *final){


    int outputLength = strlen(output);
    int finalIndex = 0;
    int consecutiveOnes = 0;
    int skipNextZero = 0;


    for (int i = 0; i < outputLength; i++) {
        if (skipNextZero) {
            // Skip the '0' that follows five consecutive '1s'
            skipNextZero = 0;
            continue;
        }


        if (output[i] == '1') {
            consecutiveOnes++;


            if (consecutiveOnes == 5) {
                skipNextZero = 1;         // Reset consecutiveOnes counter
            }
        } else {
            consecutiveOnes = 0;  // Reset consecutiveOnes counter if a '0' is encountered
        }
        final[finalIndex++] = output[i];
    }


    final[finalIndex] = '\0';  // Null-terminate the output string


}


int main()
{
    int serversocket, clientsocket, bindstatus;
    char servermessage[256];
    struct sockaddr_in serveraddress, clientaddress;
    int client_address_len = sizeof(clientaddress);


    serversocket = socket(AF_INET, SOCK_STREAM, 0);
    if (serversocket < 0)
    {
        printf("socket failed\n");
        return -1;
    }


    serveraddress.sin_family = AF_INET;
    serveraddress.sin_port = htons(PORT);
    serveraddress.sin_addr.s_addr = INADDR_ANY;


    bindstatus = bind(serversocket, (const struct sockaddr *)&serveraddress, sizeof(serveraddress));
    if (bindstatus < 0)
    {
        printf("binding failed\n");
        return -1;
    }
    else
    {
        printf("binding is successful\n");
    }


    listen(serversocket, 3);
    printf("waiting for client connection...\n");


    clientsocket = accept(serversocket, (struct sockaddr *)&clientaddress, (socklen_t *)&client_address_len);
    if (clientsocket < 0)
    {
        printf("connection is rejected by server\n");
        return -1;
    }
    else
    {
        printf("connection is accepted\n");
    }
    char output[256];
    char final[256];
    recv(clientsocket,output,sizeof(output),0);
    printf("Date recieved after bit stuffing: %s\n",output);
    ogdata(output,final);


    printf("Retrieved original data: %s\n",final);
    close(serversocket);
    return 0;
}
b) byte stuffing
client:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>


#define PORT 8000
#define MAX_MESSAGE_SIZE 1024


void byteStuff(char* input, char* output) {
    int inputLength = strlen(input);
    int outputIndex = 0;


    // Start flag byte
    output[outputIndex++] = 0x7E;


    for (int i = 0; i < inputLength; i++) {
        if (input[i] == 0x7E) {
            // If the byte is 0x7E, escape it by adding another 0x7E
            output[outputIndex++] = 0x7D;
            output[outputIndex++] = 0x5E; // Transformed 0x7E
        } else {
            output[outputIndex++] = input[i];
        }
    }


    // End flag byte
    output[outputIndex++] = 0x7E;


    output[outputIndex] = '\0'; // Null-terminate the output string
}


int main() {
    struct sockaddr_in serveraddress;
    char message[MAX_MESSAGE_SIZE];
    char stuffedMessage[MAX_MESSAGE_SIZE];


    int clientsocket;
    clientsocket = socket(AF_INET, SOCK_STREAM, 0);
    if (clientsocket < 0) {
        printf("Socket creation failed\n");
        return -1;
    }


    serveraddress.sin_family = AF_INET;
    serveraddress.sin_port = htons(PORT);
    serveraddress.sin_addr.s_addr = INADDR_ANY;


    int connection_status;
    connection_status = connect(clientsocket, (struct sockaddr *)&serveraddress, sizeof(serveraddress));
    if (connection_status < 0) {
        printf("Connection failed\n");
        return -1;
    } else {
        printf("Connection established\n");
    }


    printf("Enter Data: ");
    scanf("%s", message);


    byteStuff(message, stuffedMessage);


    printf("After byte stuffing: %s\n", stuffedMessage);


    send(clientsocket, stuffedMessage, strlen(stuffedMessage), 0);


    close(clientsocket);


    return 0;
}
server:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>


#define PORT 8000
#define MAX_MESSAGE_SIZE 1024


void byteUnstuff(char* input, char* output) {
    int inputLength = strlen(input);
    int outputIndex = 0;
    int escapeFlag = 0;


    for (int i = 0; i < inputLength; i++) {
        if (input[i] == 0x7D) {
            // Check for escape byte
            escapeFlag = 1;
        } else if (escapeFlag == 1) {
            // Handle escape sequence
            output[outputIndex++] = input[i] ^ 0x20; // XOR with 0x20 to unescape
            escapeFlag = 0;
        } else {
            output[outputIndex++] = input[i];
        }
    }


    output[outputIndex] = '\0'; // Null-terminate the output string
}


int main() {
    int serversocket, clientsocket, bindstatus;
    char servermessage[MAX_MESSAGE_SIZE];
    char unstuffedMessage[MAX_MESSAGE_SIZE];


    struct sockaddr_in serveraddress, clientaddress;
    int client_address_len = sizeof(clientaddress);


    serversocket = socket(AF_INET, SOCK_STREAM, 0);
    if (serversocket < 0) {
        printf("Socket failed\n");
        return -1;
    }


    serveraddress.sin_family = AF_INET;
    serveraddress.sin_port = htons(PORT);
    serveraddress.sin_addr.s_addr = INADDR_ANY;


    bindstatus = bind(serversocket, (const struct sockaddr *)&serveraddress, sizeof(serveraddress));
    if (bindstatus < 0) {
        printf("Binding failed\n");
        return -1;
    } else {
        printf("Binding is successful\n");
    }


    listen(serversocket, 3);
    printf("Waiting for client connection...\n");


    clientsocket = accept(serversocket, (struct sockaddr *)&clientaddress, (socklen_t *)&client_address_len);
    if (clientsocket < 0) {
        printf("Connection is rejected by server\n");
        return -1;
    } else {
        printf("Connection is accepted\n");
    }


    while (1) {
        // Receive a message from the client
        memset(servermessage, 0, sizeof(servermessage));
        ssize_t bytes_received = recv(clientsocket, servermessage, sizeof(servermessage), 0);


        // Perform byte unstuffing to handle flag bytes (0x7E)
        byteUnstuff(servermessage, unstuffedMessage);


        printf("Client: %s\n", unstuffedMessage);


        if (strcmp(unstuffedMessage, "bye") == 0) {
            printf("Client said goodbye. Exiting...\n");
            break;
        }
        break;
    }


    close(clientsocket);
    close(serversocket);


    return 0;
}
3.go back n
client:


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>


#define PORT 8000


int main()
{
    struct sockaddr_in serveraddress;


    int clientsocket;
    clientsocket = socket(AF_INET, SOCK_STREAM, 0);
    if(clientsocket<0)
    {
        printf("socket creation failed\n");
        return -1;
    }


    serveraddress.sin_family = AF_INET;
    serveraddress.sin_port = htons(PORT);
    serveraddress.sin_addr.s_addr = INADDR_ANY;


    int connection_status;
    connection_status = connect(clientsocket, (struct sockaddr *)&serveraddress, sizeof(serveraddress));
    if(connection_status < 0)
    {
        printf("connection failed\n");
        return -1;
    }
    else
        printf("connection established\n");


    int n, f;
    printf("Enter the size: ");
    scanf("%d", &n);


    printf("\nEnter the frame size: ");
    scanf("%d", &f);


    send(clientsocket, &n, sizeof(n), 0);
    send(clientsocket, &f, sizeof(f), 0);


    int j=0,ack=0,pre=-1,count=1,c=1;
     
      for(int i=0;i<n+f;i++)
      {
         if(i<f)
         {
            send(clientsocket,&i,sizeof(j), 0);
            printf("\nbit sent:%d",i);
         }
         else
         {
       
            recv(clientsocket,&ack,sizeof(j), 0);
           c=1;
            if(ack!=pre+1&&count!=2)
             {
              
                 i=pre+1;
                 count=2;
                 c=2;


                 printf("\n ack not received for the bit  =%d",ack+1);
             }
             if(c!=2&&ack<n)
            printf("\n ack received:%d",ack);
            if(i<n){
            send(clientsocket,&i,sizeof(ack), 0);
            printf("\nbit sent:%d",i);
            }
            pre++;
         }
      }






    close(clientsocket);


    return 0;
}
server:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>


#define PORT 8000


int main()
{
    char servermessage[256];
    struct sockaddr_in serveraddress, clientaddress;
    int client_address_len = sizeof(clientaddress);


    int serversocket;
    serversocket = socket(AF_INET, SOCK_STREAM, 0); 
    if(serversocket < 0)
    {
        printf("socket failed");
        return -1;
    }


    serveraddress.sin_family = AF_INET;
    serveraddress.sin_port = htons(PORT);
    serveraddress.sin_addr.s_addr = INADDR_ANY;


    int bindstatus;
    bindstatus = bind(serversocket, (const struct sockaddr*)&serveraddress, sizeof(serveraddress));
    if (bindstatus < 0)
    {
        printf("binding failed\n");
        return -1;
    }
    else
    {
        printf("binding is successful\n");
    }




    listen(serversocket, 3);
    printf("Waiting for client connection...\n");


    int clientsocket;
    clientsocket = accept(serversocket, (struct sockaddr *)&clientaddress, (socklen_t *)&client_address_len);
    if(clientsocket<0)
    {
        printf("connection is rejected by server\n");
        return -1;
    } 
    else
        printf("connection is accepted\n");


    int j=0,f,n,ack=0,count=1,c=1;
        recv(clientsocket,&n,sizeof(n), 0);
        recv(clientsocket,&f,sizeof(f), 0);
      for(int i=0;i<n+f;i++)
      {
         if(i<f)
         {
            recv(clientsocket,&j,sizeof(j), 0);
            printf("\nbit recieved:%d",j);
         }
         else
         {
             c=1;
             if(i==f+2&&count!=2)
             {
                printf("\n do you want to send ack for bit=%d??y/n:",ack);
                char ans;
                scanf("%c",&ans);
                if(ans=='n'&&count!=2)
                {
                  i=ack;
                  ack-=1;
                 count=2;
                 c=2;
                }
             }
            send(clientsocket,&ack,sizeof(ack),0);
            if(c!=2&&ack<n)
            printf("\nsending ack for:%d",ack);
            if(i<n){
            recv(clientsocket,&j,sizeof(j), 0);
            printf("\n bit received:%d",j);
            }
           
            ack++;
         }
      }
    


    close(serversocket);


    return 0;
}
4. selective repeate
client:


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>


#define PORT 8000
#define N 100 // Assuming N is the window size for selective repeat


int main() {
    struct sockaddr_in serveraddress;


    int clientsocket;
    clientsocket = socket(AF_INET, SOCK_STREAM, 0);
    if (clientsocket < 0) {
        printf("socket creation failed\n");
        return -1;
    }


    serveraddress.sin_family = AF_INET;
    serveraddress.sin_port = htons(PORT);
    serveraddress.sin_addr.s_addr = INADDR_ANY;


    int connection_status;
    connection_status = connect(clientsocket, (struct sockaddr *)&serveraddress, sizeof(serveraddress));
    if (connection_status < 0) {
        printf("connection failed\n");
        return -1;
    } else
        printf("connection established\n");


    int count = 0;
    char data[20];
    int k;


    recv(clientsocket, &k, sizeof(k), 0);


    int window_start = 0;
    int window_end = N - 1;


    while (window_start < k) {
        for (int i = window_start; i <= window_end && i < k; i++) {
            recv(clientsocket, &data[i], sizeof(data[i]), 0);
            printf("Received bit %d from server\n", i + 1);
        }


        for (int i = window_start; i <= window_end && i < k; i++) {
            int x;
            do {
                printf("+ve ack - 1/-ve ack - 2: ");
                scanf("%d", &x);


                if (x == 1) {
                    count = i + 1; // Positive acknowledgment received
                    send(clientsocket, &count, sizeof(count), 0);
                    window_start++;
                    break; // Exit the loop after sending acknowledgment


                } else if (x == 2) {
                    // Negative acknowledgment received or invalid input
                    send(clientsocket, &count, sizeof(count), 0);
                    // Continue to the next bit without waiting for acknowledgment
                    break;


                } else {
                    printf("Invalid input. Please enter 1 or 2.\n");
                }
            } while (1); // Keep asking for acknowledgment until valid input is received
        }
    }


    printf("\nData received from the server is %s \n", data);


    close(clientsocket);
    return 0;
}
server:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>


#define PORT 8000
#define N 100 // Assuming N is the window size for selective repeat


int main() {
    int serversocket, clientsocket, bindstatus;
    char servermessage[256];
    struct sockaddr_in serveraddress, clientaddress;
    int client_address_len = sizeof(clientaddress);


    serversocket = socket(AF_INET, SOCK_STREAM, 0);
    if (serversocket < 0) {
        printf("socket failed\n");
        return -1;
    }


    serveraddress.sin_family = AF_INET;
    serveraddress.sin_port = htons(PORT);
    serveraddress.sin_addr.s_addr = INADDR_ANY;


    bindstatus = bind(serversocket, (const struct sockaddr *)&serveraddress, sizeof(serveraddress));
    if (bindstatus < 0) {
        printf("binding failed\n");
        return -1;
    } else {
        printf("binding is successful\n");
    }


    listen(serversocket, 100);
    printf("Waiting for client connection...\n");


    clientsocket = accept(serversocket, (struct sockaddr *)&clientaddress, (socklen_t *)&client_address_len);
    if (clientsocket < 0) {
        printf("connection is rejected by server\n");
        return -1;
    } else {
        printf("connection is accepted\n");
    }


    char data[20];
    printf("Enter the data: ");
    scanf("%s", data);


    int count = 0, j = 1;
    int k = strlen(data);
    int window_start = 0;
    int window_end = N - 1;


    send(clientsocket, &k, sizeof(k), 0);


    while (window_start < k) {
        for (int i = window_start; i <= window_end && i < k; i++) {
            send(clientsocket, &data[i], sizeof(data[i]), 0);
        }


        for (int i = window_start; i <= window_end && i < k; i++) {
            recv(clientsocket, &count, sizeof(count), 0);
            if (count == j) {
                printf("\nAcknowledgment received for bit %d", j);
                j++;
                window_start++;
                window_end++;
            } else {
                printf("\nAcknowledgment not received for bit %d, resending", j);
                j++;
                count++;
            }
        }
    }


    close(serversocket);
    return 0;
}
5.stop and wait


client:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>


#define PORT 8000


int main()
{
    struct sockaddr_in serveraddress;


    int clientsocket;
    clientsocket = socket(AF_INET, SOCK_STREAM, 0);
    if(clientsocket<0)
    {
        printf("socket creation failed\n");
        return -1;
    }


    serveraddress.sin_family = AF_INET;
    serveraddress.sin_port = htons(PORT);
    serveraddress.sin_addr.s_addr = INADDR_ANY;


    int connection_status;
    connection_status = connect(clientsocket, (struct sockaddr *)&serveraddress, sizeof(serveraddress));
    if(connection_status < 0)
    {
        printf("connection failed\n");
        return -1;
    }
    else
        printf("connection established\n");


    
    int count = 0;
    char data[20];
    int k;


    recv(clientsocket, &k, sizeof(k), 0);


    for(int i = 0; i < k; i++)
    {
        recv(clientsocket, &data[i], sizeof(data[i]), 0);
        printf("Received bit %d from server\n", i+1);


        if(i == 3)
        {
            int x;
            printf("Press 1 if you want to send ack, else press 2: ");
            scanf("%d", &x);


            if(x == 1)
            {
                count++;
                send(clientsocket, &count, sizeof(count) ,0);
            }
            else
                count++;
        }
        else
        {
            count++;
            send(clientsocket, &count, sizeof(count), 0);
        }
    }


    printf("\nData received from the server is %s ", data);




    close(clientsocket);


    return 0;
}
6.stop and wait(APR)
client:
#include<stdio.h>
#include<stdlib.h>
#include<sys/socket.h>
#include<sys/types.h>
#include<netinet/in.h>
#include<sys/time.h>
#include<sys/wait.h>
#include<string.h>
#include<unistd.h>
#include<arpa/inet.h> 
int main() {
	int c_sock;
	c_sock = socket(AF_INET, SOCK_STREAM, 0);
	struct sockaddr_in client;
	memset(&client, 0, sizeof(client));
	client.sin_family = AF_INET;
	client.sin_port = htons(9009);
	client.sin_addr.s_addr = inet_addr("127.0.0.1");
	


	if(connect(c_sock, (struct sockaddr*)&client, sizeof(client)) == -1) {
	printf("Connection failed");
	return 0;
	}
	char msg1[50]="akwnowledgement-0";
    char msg2[50]="akwnowledgement-1";


	char buff[100];
	int flag=1,flg=1,flag2=1;
	for(int i=0;i<10;i++) {
		flg=1;
		bzero(buff,sizeof(buff));
        if((i==3&&flag==1)||(i==7&&flag2==1)){
			printf("\nproblem/corruption simulation\n");
			if(i==3&&flag==1)
			flag=0;
			else if(flag==0)
			flag2=0;            
			i--;
			read(c_sock,buff,sizeof(buff));
			//printf("aa %s \n",buff);
			continue;
        }
		int n = read(c_sock, buff, sizeof(buff));
		//buff[n] = '\0';
        if(buff[strlen(buff)-1]!=i+'0'){          //akw not received at server,so discard
        printf("\nDiscarding packet\n");
        //printf("%c, %c, -- %s\n",buff[strlen(buff)-1],'0'+i,buff);
        //flg=0;
		i--;
		continue;
        //goto qq;
        }
		printf("Message received from server : %s \n",buff);
        printf("Aknowledgement sent \n");
        qq:
        if(i%2==0)
		write(c_sock,msg2, sizeof(msg2));
        else 
 		write(c_sock,msg1, sizeof(msg1));    
		if(flg==0)
		i--;   
	}
	
	close(c_sock);
	return 0;
}
server
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>


#define PORT 8000


int main()
{
    char servermessage[256];
    struct sockaddr_in serveraddress, clientaddress;
    int client_address_len = sizeof(clientaddress);


    int serversocket;
    serversocket = socket(AF_INET, SOCK_STREAM, 0); 
    if(serversocket < 0)
    {
        printf("socket failed");
        return -1;
    }


    serveraddress.sin_family = AF_INET;
    serveraddress.sin_port = htons(PORT);
    serveraddress.sin_addr.s_addr = INADDR_ANY;


    int bindstatus;
    bindstatus = bind(serversocket, (const struct sockaddr*)&serveraddress, sizeof(serveraddress));
    if (bindstatus < 0)
    {
        printf("binding failed\n");
        return -1;
    }
    else
    {
        printf("binding is successful\n");
    }




    listen(serversocket, 3);
    printf("Waiting for client connection...\n");


    int clientsocket;
    clientsocket = accept(serversocket, (struct sockaddr *)&clientaddress, (socklen_t *)&client_address_len);
    if(clientsocket<0)
    {
        printf("connection is rejected by server\n");
        return -1;
    } 
    else
        printf("connection is accepted\n");




    char data[20];
    printf("Enter the data: ");
    scanf("%s", data);


    int count = 0, j = 1;
    int k = strlen(data);


    send(clientsocket, &k, sizeof(k), 0);


    for(int i = 0; i < k; i++)
    {   send(clientsocket, &data[i], sizeof(data[i]), 0);


        recv(clientsocket, &count, sizeof(count), 0);


        if(count == j)
        {
            printf("\nAcknowledgement received for bit %d from client ", j);
            j++;
        }
        else
        {
            printf("\nAcknowledgement not received for bit %d ", j);
            j++;
        }
    }
    


    close(serversocket);


    return 0;
}


7.tcp calculatar
client:


#include<stdio.h>
#include<stdlib.h>
#include <unistd.h>
#include<string.h>
#include<sys/socket.h>
#include<sys/types.h>
#include<netinet/in.h>
int main(){
    int c_sock;
    char msg[20]="Hello server";
    char buf[200];
    char var[10];
    c_sock = socket(AF_INET,SOCK_STREAM,0);
    struct sockaddr_in  client;
    memset(&client,0,sizeof(client));
    client.sin_family=AF_INET;
    client.sin_port=htons(9009);
    client.sin_addr.s_addr=INADDR_ANY;
    if(connect(c_sock,(struct sockaddr*)&client,sizeof(client))==-1){
        printf("\nServer busy/down");
        return 0;
    }


    recv(c_sock,buf,sizeof(buf),0);
    qq:


    printf("%s",buf);
    scanf("%s",var);
    send(c_sock,var,sizeof(var),0);
    if(recv(c_sock,buf,sizeof(buf),0)){
        goto qq;
    }
    close(c_sock);
    return 0;
}
server:
#include<stdio.h>
#include<stdlib.h>
#include <unistd.h>
#include<string.h>
#include<sys/socket.h>
#include<sys/types.h>
#include<netinet/in.h>
int main(){
    int c_sock,s_sock;
    char msg[100]="\t\tInteger Calculator\n1)Add\t2)Subtract\t3)Multipily\t4)divide\nElse any to exit \nSelect Option : ";
    char msg1[40]="Enter First Number  :";
    char msg2[40]="Enter Second Number :";
    char msg3[100]="Answer : ";
    char msg4[70]="\nThank you,disconnecting ...Press any key and enter to exit \n";
    char buf[25];
    int z,x1,x2;    //z-option x-variable
    s_sock = socket(AF_INET,SOCK_STREAM,0);
    struct sockaddr_in  server,other;
    memset(&server,0,sizeof(server));
    memset(&other,0,sizeof(other));
    server.sin_family=AF_INET;
    server.sin_port=htons(9009);
    server.sin_addr.s_addr=INADDR_ANY;
    socklen_t add;
    bind(s_sock,(struct sockaddr*)&server,sizeof(server));
    listen(s_sock,10);
    add=sizeof(other);
    c_sock=accept(s_sock,(struct sockaddr*)&other,&add);
    send(c_sock,msg,sizeof(msg),0);
    recv(c_sock,buf,sizeof(buf),0);
    if(buf){
        printf("A connection is established");
    }
    z=atoi(buf);
    if(z>=1&&z<=4)  {
    send(c_sock,msg1,sizeof(msg1),0);
    recv(c_sock,buf,sizeof(buf),0);
    x1=atoi(buf);
    send(c_sock,msg2,sizeof(msg2),0);
    recv(c_sock,buf,sizeof(buf),0);
    x2=atoi(buf);
    switch (z)
    {
    case 1:x1=x1+x2;
    break;
    case 2:x1=x1-x2;
    break;
    case 3:x1=x1*x2;
    break;
    case 4:x1=x1/x2;
    break;
    default:
    break;
    }
    char ans[10];
    sprintf(ans,"%d",x1);
    strcat(msg3,ans);
    strcat(msg3,msg4);
    send(c_sock,msg3,sizeof(msg3),0);
    }
    else
    send(c_sock,msg4,sizeof(msg3),0);
    printf("\nDisconnected with client");
    close(s_sock);
    return 0;
}
ECHO
client:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define MAX_BUFFER_SIZE 1024

int main() {
    int client_socket;
    struct sockaddr_in server_addr;

    if ((client_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);

    if (inet_pton(AF_INET, "127.0.0.1", &server_addr.sin_addr) <= 0) {
        perror("Invalid address / Address not supported");
        exit(EXIT_FAILURE);
    }

    if (connect(client_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("Connection failed");
        exit(EXIT_FAILURE);
    }

    char message[MAX_BUFFER_SIZE];

    while (1) {
        printf("Enter a message to send (or 'exit' to quit): ");
        fgets(message, sizeof(message), stdin);

        if (strncmp(message, "exit", 4) == 0) {
            break;
        }

        send(client_socket, message, strlen(message), 0);

        char buffer[MAX_BUFFER_SIZE];
        int read_bytes;

        read_bytes = recv(client_socket, buffer, sizeof(buffer), 0);
        if (read_bytes <= 0) {
            break;
        }

        buffer[read_bytes] = '\0';
        printf("Server response: %s", buffer);
    }

    close(client_socket);

    return 0;
}
srever:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define MAX_BUFFER_SIZE 1024

int main() {
    int server_socket, client_socket;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_addr_len = sizeof(client_addr);

    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("Binding failed");
        exit(EXIT_FAILURE);
    }

    if (listen(server_socket, 5) < 0) {
        perror("Listening failed");
        exit(EXIT_FAILURE);
    }

    printf("Server listening on port %d...\n", PORT);

    if ((client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_addr_len)) < 0) {
        perror("Acceptance failed");
        exit(EXIT_FAILURE);
    }

    char buffer[MAX_BUFFER_SIZE];
    int read_bytes;

    while (1) {
        read_bytes = recv(client_socket, buffer, sizeof(buffer), 0);
        if (read_bytes <= 0) {
            break;
        }

        buffer[read_bytes] = '\0';
        printf("Received: %s", buffer);

        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    close(server_socket);

    return 0;
}
SLIDING WINDOW
client:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define PORT 8000

int main()
{
    struct sockaddr_in serveraddress;

    int clientsocket;
    clientsocket = socket(AF_INET, SOCK_STREAM, 0);
    if(clientsocket<0)
    {
        printf("socket creation failed\n");
        return -1;
    }

    serveraddress.sin_family = AF_INET;
    serveraddress.sin_port = htons(PORT);
    serveraddress.sin_addr.s_addr = INADDR_ANY;

    int connection_status;
    connection_status = connect(clientsocket, (struct sockaddr *)&serveraddress, sizeof(serveraddress));
    if(connection_status < 0)
    {
        printf("connection failed\n");
        return -1;
    }
    else
        printf("connection established\n");

    int n, f;
    printf("Enter the size: ");
    scanf("%d", &n);

    printf("Enter the frame size: ");
    scanf("%d", &f);

    send(clientsocket, &n, sizeof(n), 0);
    send(clientsocket, &f, sizeof(f), 0);

    int ack, read1;

    for(int j = 0; j < f; j++)
    {
        printf("\nsending the bit: %d", j);
        send(clientsocket, &j, sizeof(j), 0);
        sleep(2);
    }

    for(int i = f; i < n; i++)
    {
        sleep(2);
        send(clientsocket, &i, sizeof(i), 0);

        printf("\nsending bit %d...", i);
        sleep(2);

        recv(clientsocket, &ack, sizeof(ack), 0);

        printf("\nack bit: %d\n\n", ack);
    }

    for(int j = n-f; j < n; j++)
    {
        recv(clientsocket, &ack, sizeof(ack), 0);
        printf("\nack bit: %d\n\n", ack);
    }


    close(clientsocket);

    return 0;
}
server:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define PORT 8000
#define N 100 // Assuming N is the window size for selective repeat

int main() {
    int serversocket, clientsocket, bindstatus;
    char servermessage[256];
    struct sockaddr_in serveraddress, clientaddress;
    int client_address_len = sizeof(clientaddress);

    serversocket = socket(AF_INET, SOCK_STREAM, 0);
    if (serversocket < 0) {
        printf("socket failed\n");
        return -1;
    }

    serveraddress.sin_family = AF_INET;
    serveraddress.sin_port = htons(PORT);
    serveraddress.sin_addr.s_addr = INADDR_ANY;

    bindstatus = bind(serversocket, (const struct sockaddr *)&serveraddress, sizeof(serveraddress));
    if (bindstatus < 0) {
        printf("binding failed\n");
        return -1;
    } else {
        printf("binding is successful\n");
    }

    listen(serversocket, 100);
    printf("Waiting for client connection...\n");

    clientsocket = accept(serversocket, (struct sockaddr *)&clientaddress, (socklen_t *)&client_address_len);
    if (clientsocket < 0) {
        printf("connection is rejected by server\n");
        return -1;
    } else {
        printf("connection is accepted\n");
    }

    char data[20];
    printf("Enter the data: ");
    scanf("%s", data);

    int count = 0, j = 1;
    int k = strlen(data);
    int window_start = 0;
    int window_end = N - 1;

    send(clientsocket, &k, sizeof(k), 0);

    while (window_start < k) {
        for (int i = window_start; i <= window_end && i < k; i++) {
            send(clientsocket, &data[i], sizeof(data[i]), 0);
        }

        for (int i = window_start; i <= window_end && i < k; i++) {
            recv(clientsocket, &count, sizeof(count), 0);
            if (count == j) {
                printf("\nAcknowledgment received for bit %d", j);
                j++;
                window_start++;
                window_end++;
            } else {
                printf("\nAcknowledgment not received for bit %d, resending", j);
                j++;
                count++;
            }
        }
    }

    close(serversocket);
    return 0;
}
HAMMING
client:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include<math.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define PORT 8000

int i, j;
char data[20], final_data[20], rec_data[20];

void even_parity(int *parity_index, int parity_index_size, int x, char *final_data)
{
    int count = 0;
    for(i = 0; i < parity_index_size; i++)
    {
        int index = parity_index[i];
        if(final_data[index] == '1')
            count++;
    }

    if(count % 2 != 0)
        final_data[x] = '1';
    else
        final_data[x] = '0';

    printf("Final string: %s\n", final_data);
}

void strrev(char *rec_data)
{
    int len;
    len = strlen(rec_data);
    int start = 0, end = len - 1;
    while(start < end)
    {
        char temp = rec_data[start];
        rec_data[start] = rec_data[end];
        rec_data[end] = temp;
        start++;
        end--;
    }
}


int main()
{
    struct sockaddr_in serveraddress;

    int clientsocket;
    clientsocket = socket(AF_INET, SOCK_STREAM, 0);
    if(clientsocket<0)
    {
        printf("socket creation failed\n");
        return -1;
    }

    serveraddress.sin_family = AF_INET;
    serveraddress.sin_port = htons(PORT);
    serveraddress.sin_addr.s_addr = INADDR_ANY;

    int connection_status;
    connection_status = connect(clientsocket, (struct sockaddr *)&serveraddress, sizeof(serveraddress));
    if(connection_status < 0)
    {
        printf("connection failed\n");
        return -1;
    }
    else
        printf("connection established\n");

    
    printf("Enter the 7 bit data: ");
    scanf("%s", data);

    int data_length = strlen(data);

    strrev(data);

    int current_data_index = 0;
    int final_data_index = 0;

    for(i = 1; i<= data_length + 4; i++)
    {
        if((i & (i-1)) == 0)
        {
            final_data[final_data_index] = '_';
            final_data_index++;
        }
        else
        {
            final_data[final_data_index] = data[current_data_index];
            final_data_index++;
            current_data_index++;
        }
    }

    final_data[final_data_index] = '\0';
    printf("Final data string is: %s\n", final_data);

    int parity_index1[] = {0, 2, 4, 6, 8, 10};
    int parity_index2[] = {1, 2, 5, 6, 9, 10};
    int parity_index3[] = {3, 4, 5, 6};
    int parity_index4[] = {7, 8, 9, 10};

    int parity_index1_size = sizeof(parity_index1) / sizeof(parity_index1[0]);
    int parity_index2_size = sizeof(parity_index2) / sizeof(parity_index2[0]);
    int parity_index3_size = sizeof(parity_index3) / sizeof(parity_index3[0]);
    int parity_index4_size = sizeof(parity_index4) / sizeof(parity_index4[0]);

    even_parity(parity_index1, parity_index1_size, 0, final_data);
    even_parity(parity_index2, parity_index2_size, 1, final_data);
    even_parity(parity_index3, parity_index3_size, 3, final_data);
    even_parity(parity_index4, parity_index4_size, 7, final_data);

    strrev(final_data);

    printf("The string to be transmitted is: %s\n", final_data);

    send(clientsocket, final_data, sizeof(final_data), 0);

    close(clientsocket);

    return 0;
}
server:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>



#define PORT 8000

int i, j;
char data[20], final_data[20], rec_data[20];

int parity_check(int *parity_index, int parity_index_size, char *rec_data)
{
    int x;
    int count = 0;
    for(i = 0; i < parity_index_size; i++)
    {
        int index = parity_index[i];
        if(rec_data[index]== '1')
            count++;
    }

    if(count % 2 != 0)
        x = 1;
    else
        x = 0;

    return x;
}

void strrev(char *rec_data)
{
    int len;
    len = strlen(rec_data);
    int start = 0, end = len - 1;
    while(start < end)
    {
        char temp = rec_data[start];
        rec_data[start] = rec_data[end];
        rec_data[end] = temp;
        start++;
        end--;
    }
}

int main()
{
    char servermessage[256];
    struct sockaddr_in serveraddress, clientaddress;
    int client_address_len = sizeof(clientaddress);

    int serversocket;
    serversocket = socket(AF_INET, SOCK_STREAM, 0); 
    if(serversocket < 0)
    {
        printf("socket failed");
        return -1;
    }

    serveraddress.sin_family = AF_INET;
    serveraddress.sin_port = htons(PORT);
    serveraddress.sin_addr.s_addr = INADDR_ANY;

    int bindstatus;
    bindstatus = bind(serversocket, (const struct sockaddr*)&serveraddress, sizeof(serveraddress));
    if (bindstatus < 0)
    {
        printf("binding failed\n");
        return -1;
    }
    else
    {
        printf("binding is successful\n");
    }


    listen(serversocket, 3);
    printf("Waiting for client connection...\n");

    int clientsocket;
    clientsocket = accept(serversocket, (struct sockaddr *)&clientaddress, (socklen_t *)&client_address_len);
    if(clientsocket<0)
    {
        printf("connection is rejected by server\n");
        return -1;
    } 
    else
        printf("connection is accepted\n");

    recv(clientsocket, final_data, sizeof(final_data), 0);
    printf("Received data: %s\n", final_data);

    printf("Enter the data received: ");
    scanf("%s", rec_data);

    strrev(rec_data);

    int parity_index1[] = {0, 2, 4, 6, 8, 10};
    int parity_index2[] = {1, 2, 5, 6, 9, 10};
    int parity_index3[] = {3, 4, 5, 6};
    int parity_index4[] = {7, 8, 9, 10};

    int parity_index1_size = sizeof(parity_index1) / sizeof(parity_index1[0]);
    int parity_index2_size = sizeof(parity_index2) / sizeof(parity_index2[0]);
    int parity_index3_size = sizeof(parity_index3) / sizeof(parity_index3[0]);
    int parity_index4_size = sizeof(parity_index4) / sizeof(parity_index4[0]);
    
    char parity_results[4];

    parity_results[3] = parity_check(parity_index1, parity_index1_size, rec_data);
    parity_results[2] = parity_check(parity_index2, parity_index2_size, rec_data);
    parity_results[1] = parity_check(parity_index3, parity_index3_size, rec_data);
    parity_results[0] = parity_check(parity_index4, parity_index4_size, rec_data);

    printf("Parity check results: P8: %d, P4: %d, P2: %d, P1: %d\n", parity_results[0], parity_results[1], parity_results[2], parity_results[3]);

    int sum = 0;
    for(i = 0; i < 4; i++)
    {
        int y = sizeof(parity_results) - (i+1);
        sum = sum + parity_results[i]*pow(2, y);
    }

    if(sum == 0)
        printf("\nNo error\n");
    else
        printf("\nError in bit %d\n", sum);

    close(serversocket);

    return 0;
}

